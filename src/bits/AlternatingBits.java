package bits;

/**
 * @author Zhang Xinyu
 * @version 1.0
 * @date 2020/2/13 14:00
 * 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。
 * 101010交替
 */
public class AlternatingBits {
    /*
     * 分析：
     * 如果n是交替的01，对于它右移一位后得到的m，
     * 存在n跟m在二进制下必然是0和1对应的（对位）。异或运算必定都是1；
     * 举个栗子：5=101 5>>1=10,5^(5>>1)=111 (这是伪代码)
     *  101
     *   10  =111
     * 其他情况都不会满足这个特征。所以temp=n^(n>>1)必定满足temp=2^N-1;
     * 而temp+1后是N+1位二进制数2^(N+1)。
     * 所以temp&(temp+1)==0；
     * 如果满足这个等式就是就是交替位二进制数
     */
    public boolean hasAlternatingBits(int n) {
        // 如果是交替，那么如果向右移动一位的话，位数岔开一定是不一样的,a 一定为11111(n个1)
        int a = n ^ (n >> 1);
        // a + 1  10000 2^(N+1) 最高位为1其余位为0，这样再与原来全是1111的a与就是0
        // 10000
        //  1111 = 0
        return (a & (a + 1)) == 0;
    }
}
