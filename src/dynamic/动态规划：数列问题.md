# 动态规划：数列问题

## 问题1 爬楼梯

 [LeetCode：爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 问题描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数

```
示例 1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

### 思路

采用动态规划的思想

#### 一、状态

可以定义一个一维数组作为动态规划数组 `dp[i]`表示 爬到第 `i`  阶楼梯需要多少种方法 。

#### 二、状态转移方程

- ##### 问题拆解：大问题的最优解如何由小问题的最优解得到

  因为每次爬楼梯都只能爬 1 个台阶或 2 个台阶，在第 `i` 个台阶时分解子问题时可以得到两种情况：

  - 最后还剩一个台阶的话，就是前 `i - 1` 个台阶方法的基础上再爬一阶
  - 最后还剩两个台阶的话，就是前 `i - 2` 个台阶方法的基础上再爬两阶
  - 最后的方法数就是两个情况的总和

- ##### 状态转移方程

  ```java
  dp[i] = dp[i - 1] + dp[i - 2]
  ```

#### 三、初始化

第一个和第二个台阶的方法可计算

```java
dp[1] = 1;
dp[2] = 2;
```

#### 四、输出

n个台阶直接返回`dp[n]`即可

### 代码

```java
public int climbStairs(int n) {
    if (n == 1) return 1;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < dp.length; i++){
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```



##  问题2  打劫家舍

[LeetCode: 打劫家舍](https://leetcode-cn.com/problems/house-robber)

### 问题描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

```java 
示例 1:

输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 
```

### 思路

采用动态规划的思想

#### 一、状态

可以定义一个一维数组作为动态规划数组 `dp[i]`表示 打劫第 `i`  个房子时的最高金额

#### 二、状态转移方程

- ##### 问题拆解：大问题的最优解如何由小问题的最优解得到

  从**问题的求解和过程分析**：到第 `i` 个房屋时偷窃房屋无非就是**两种情况**：偷或者不偷

  - 偷第 `i` 个房屋，因为不能偷相邻的房屋，所以只能计算偷到第 `i - 2` 个房屋的最高金额 加上 第 `i` 个房屋的金额
  - 不偷第 `i` 个房屋，则只能计算偷到第 `i - 1` 个房屋的最高金额 
  - 最后的最大金额就是比较两种情况，取最大值

- ##### 状态转移方程

  ```java
  dp[i] = Math.max(dp[i - 1],dp[i - 2] + nums[i - 1]);
  ```

#### 三、初始化

```java
dp[0] = 0;
dp[1] = nums[0];
```

#### 四、输出

动态规划数组记录的就是偷窃每个房子的最大值，直接返回`dp[n]`即可

#### 五、空间压缩

为了方便理解可以定义一个一位数组，其实也可以节省空间复杂度状态的转移只依赖于两个结果：前一步或或前两步的结果。定义两个变量分别保存前一步和前两部的最大结果即可

### 代码

```java
public int rob(int[] nums) {
    int len = nums.length;
    if(len == 0) return 0;
    int[] dp = new int[len + 1];
    dp[0] = 0;
    dp[1] = nums[0];
    for (int i = 2;i <= len;i ++){
        dp[i] = Math.max(dp[i - 1],dp[i - 2] + nums[i - 1]);
    }
    return dp[len];
}

// 优化后代码
public int rob(int[] nums) {
    // 优化，最大值最小值用变量来优化
    int curMax = 0; // 上一次循环中的最大值，在循环中更新
    int preMax = 0; // 前两次循环中的最大值，用于在循环中记录上一次的最大值
    for (int x : nums){
        int temp = curMax; // 上一次的最大值
        curMax = Math.max(x + preMax, curMax); // 用于更新
        preMax = temp; // 用于下一次的更新
    }
    return curMax;
}
```



## 问题3  打劫家舍（环形房屋）

[LeetCode: 打劫家舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

### 问题描述

增加了一个限制条件：房屋时环形的，也就是说选择了第一个房屋和最后一个房屋不能同时选择。

### 思路

可以将环形房屋转换成两个种单排列房屋问题，主要思想还是借助上一题的思想

* 在选第一个不选最后一个房屋的情况下，得到盗窃房屋金额的最大值
* 在不选第一个选择最后一个房屋的情况下，得到盗窃房屋金额的最大值
* 二者比较取最大值

### 代码

```java
  /**
     * 环形房子，可以把其看成两个单排列问题,有两种情况：
     * 1）抢了第一个房子，不抢最后一个
     * 2）不抢第二个房子，可以抢最后一个
     * 二者取最大值
     * */
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        return Math.max(robHouse(Arrays.copyOfRange(nums, 0, nums.length - 1)),
                        robHouse(Arrays.copyOfRange(nums, 1, nums.length)));
    }

    /**
     * 抢最后一个房子的情况：
     * 抢最后一个房子：f(n - 1) + nums[i]
     * 不抢最后一个房子：f(n - 2)
     */
    public int robHouse(int[] nums){
        int curMax = 0;  // 记录 f(n - 1) 的值
        int preMax = 0;  // 记录 f(n - 2) 的值
        for (int x : nums){
            int temp = curMax;
            curMax = Math.max(preMax + x, curMax);
            preMax = temp;
        }
        return curMax;
    }
```



## 问题4 乘积最大子序列

[LeetCode: 乘积最大子序列](https://leetcode-cn.com/problems/maximum-product-subarray)

### 问题描述：

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

```java
示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

### 思路

标准的动态规划解题，思路与和最大子序列一样。

#### 一、状态

先看求解问题：**输出乘积最大连续子序列的乘积，无需记录子序列的开始位置和终点位置。**

因此定义一个一维数组作为动态规划数组， `dp[i]`表示 到第 `i`  数时其最大的乘积

#### 二、状态转移方程

- ##### 问题拆解：大问题的最优解如何由小问题的最优解得到

  从**问题的求解和过程分析**：到第 `i` 个数时，最大值的取值有两种情况，设前 `i- 1` 个数的乘积为 `dp[i - 1]` ,上第 `i` 个数为 `nums[i]`:

  - 如果之前的最大乘积和当前数的乘积大于当前数，则更新最大值： `dp[i - 1] * nums[i] >= nums[i] `  则 `dp[i] = dp[i - 1] * nums[i]`  
  - 如果新的乘积不如当前的数大，因为是连续子序列，所有从当前数重新开始计乘积 `dp[i] = nums[i] `
  
- ##### 状态转移方程

  ```java
  dp[i] = Math.max(nums[i], dp[i - 1] * nums[i]);
  ```

#### 三、初始化

```java
dp[0] = nums[0]; //下标为零的最大乘积就是他自己
```

#### 四、输出

直接返回`dp[n]`即可

#### 五、空间压缩

为了方便理解可以定义一个一位数组，其实数组只是定义的最大值，其实可以定义一个变量在循环中不断更新最大值。

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE;
        int maxProduct = 1;
        int minProduct = 1;
        for (int i = 0;i < nums.length;i ++){
            if (nums[i] < 0){
                // 如果当前数为负数，则最大乘积和最小乘积交换
                int temp = maxProduct;
                maxProduct = minProduct;
                minProduct = temp;
            }
            maxProduct = Math.max(nums[i] * maxProduct, nums[i]);
            minProduct = Math.min(nums[i] * minProduct, nums[i]);//只需记录遍历到当前数为止，最小的乘积，仅供当前数为负数时交换使用
            max = Math.max(max, maxProduct);
        }
        return max;
    }
}
```

